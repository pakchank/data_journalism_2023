<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.525">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="이윤호, 변석호, 송고은, 김아은, 여진영, 신예원">

<title>projects - 1교시 통학, 괜찮아요?</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">projects</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">1교시 통학, 괜찮아요?</h1>
                      </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>이윤호, 변석호, 송고은, 김아은, 여진영, 신예원 </p>
            </div>
    </div>
      
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p><br> 통계청에서 대학생 425명을 대상으로 한 &lt;한국대학신문 캠퍼스라이프&gt;의 조사에 따르면 대학생 중 집에서 ’통학’을 하는 학생의 비율은 52%, 본가를 떠나 대학 인근에서 독립해 사는 나머지 대학생들은 약 48% 정도인 것으로 나타났다. 실제로 조사에 따라 결과는 조금씩 다르지만 통학을 하는 학생과 학교 인근에서 독립해 사는 학생의 비율이 거의 절반 정도로 나타난다.</p>
<p>그렇다면 경북대학교 학생들의 통학과 자취 비율은 어떠할까? 2020년 기준 대구에 주소지를 두고 입학한 본교 신입생 수는 2,182명이었다. 전체 입학자 수가 4,915명인 것을 고려해 보았을 때 약 44%에 해당하는 수치로 이들은 대부분 등하교를 위해 대중교통을 이용하는 통학 인원으로 추정할 수 있다.</p>
<p>코로나19로 인해 대부분 비대면 수업을 한 재작년과 작년을 거쳐 올해 대부분의 대학들이 대면 수업으로의 전환을 시도하며 1교시 통학에 대한 불만의 목소리들이 커져가고 있다. 대구 달성군 다사읍에서 통학을 하는 학생 A는 대실역에서 출발해 반월당에서 버스를 갈아탄 후 북문에서 내린다. 대략 1시간 정도 소요되지만 아침 시간의 경우 여러 고려해야 할 요소가 많다 보니 부지런히 준비해야 제시간에 도착할 수 있다.</p>
<blockquote class="blockquote">
<p><span style="font-size:78%">“직장인들, 학생들 등 많은 사람들이 오가는 아침 시간에 버스를 이용하다 보니 체력적인 부분에서의 한계 그리고 차편 부족이 가장 큰 고충이 아닐까 싶습니다. 아침 버스는 서있을 자리조차 비좁고 종종 버스 손잡이도 잡지 못한 채 휘청거리며 오는 날에는 진이 빠져 수업에 집중하기가 어려웠습니다. 그리고 버스에 사람이 너무 많으면 기다려도 못 타고 다음 버스를 타야 되니 집에서 일찍 나와도 지각을 할까 봐 억울하기도 하고 조마조마한 기분입니다.”</span></p>
</blockquote>
<p>또 다른 학생 B는 학교까지 1시간 30분 정도 소요되는 거리에서 통학을 한다.</p>
<blockquote class="blockquote">
<p><span style="font-size:78%">“1교시 통학은 기상시간이 제일 힘든 것 같습니다. 아침에 밀리는 시간까지 고려했을 때 7시가 조금 넘으면 버스를 타야 하고, 그러면 기상시간이 6시 정도로 당겨질 수밖에 없습니다. 그 뿐만 아니라 이른 등교는 출근시간과 겹쳐 교통이 혼잡하고 버스에도 사람이 가득해서 신체적으로 상당히 부담스럽습니다. 모르는 이들과 서로서로 밀착한 상태로 오랜 시간을 흔들리는 버스 안에서 버티는 것 또한 상당한 스트레스입니다.”</span></p>
</blockquote>
<p>이처럼 1교시 수업을 듣기 위해 학교로 오는 경우 다른 시간대에 비해 버스 혼잡도가 높고 버스에 사람이 많다면 버스를 타지 못하는 등의 문제가 발생한다. 게다가 경북대학교의 인근에는 지하철역이 존재하지 않기 때문에 대부분의 학생들은 버스를 타고 통학해야 하는 상황이다. 사람에 치이고 시간에 쫓기는 실정이다. 따라서 경북대학교 대구캠퍼스로 통학하는 학생들의 삶을 살펴보고 이를 통해 도출할 수 있는 방안에 대해 짚어보고자 한다.<br><br></p>
<section id="교시-수업을-듣기-위한-버스는-얼마나-혼잡할까" class="level3">
<h3 class="anchored" data-anchor-id="교시-수업을-듣기-위한-버스는-얼마나-혼잡할까"><strong>1교시 수업을 듣기 위한 버스는 얼마나 혼잡할까?</strong></h3>
<p>1교시 수업, 즉 9시 수업을 듣기 위해 이용하는 버스는 출근시간대의 영향으로 다른 시간대보다 더 많은 혼잡도를 야기한다는 것을 우리는 경험적으로 알고 있다. 그리하여 경북대학교 통학생들이 등교를 위해 이용하는 버스와 경북대학교를 지나지 않는 다른 버스와의 차이를 학기 중과 방학 중으로 나누어 비교하여 1교시 통학에 대한 어려움을 보여주고자 하였다. 또한 경북대학교를 거치는 버스에서 학기 중과 방학 중의 탑승객 수 차이를 통해 1교시 통학을 하는 경북대학교 학생의 수를 유추해볼 수 있을 것이다.</p>
<p>경북대학교 통학생들이 등교를 하기 위해 이용하는 버스노선은 410, 410-1, 503, 937, 동구2, 북구2, 300, 306, 523, 706, 719, 급행6, 323-1이 있다. 이는 경북대홈페이지의 ’찾아오시는 길’을 참고하여 선정하였다. 방학 중과 학기 중의 기간은 각각 1월, 2월, 7월, 8월과 3월, 4월, 5월, 9월, 10월, 11월으로 나누었으며 6월과 12월은 학기와 방학이 겹쳐 있어 따로 제외시켜 주었다.</p>
<p>또한, 대구에서 운행되는 버스는 노선 별로 운행 횟수의 차이가 있기 때문에 ‘대구광역시 시내버스 노선별 평균 배차간격’ 데이터를 이용하여 버스 노선 별 1시간 당 평균 운행 횟수를 구하여 결과 도출에 적용하였다.</p>
<p>대구광역시의 경우 버스 하차 시 하차태그가 의무가 아니기 때문에 데이터에 나타난 하차인원 수는 실제로 하차한 인원 수 보다 적게 입력되어 있었다. 따라서 ’대구광역시 정류소별 시간대별 승하차인원’을 이용하여 전체 승차인원과 전체 하차인원 간의 비율을 계산하여 하차태그를 하는 사람의 비중을 구해주었다. 약 35.8%의 사람들이 하차태그를 찍고 내린다는 것을 알 수 있었고 이 값을 5시부터 8시 59분까지의 하차인원수의 합에 나누어 예상 하차 인원 수를 추정하였다.</p>
<div class="cell" data-layout-align="center">
<div class="cell-output cell-output-stderr">
<pre><code>Warning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.
i Please use `linewidth` instead.</code></pre>
</div>
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="index_files/figure-html/unnamed-chunk-7-1.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>그리고 한 버스에 타고 있는 탑승객 수를 알기 위해서 5시부터 8시 59분까지 누적 승차인원 수와 하차인원 수의 차를 계산하고 시간 당 운행 회수를 나누어 주었다. 경북대학교를 거치는 버스와 경북대학교를 거치지 않는 버스, 겹치는 월을 제외한 방학 중과 학기 중을 하나의 그룹으로 설정하고 한 버스에 타고 있는 탑승객 수의 평균을 구해주었다. 결과적으로 경북대학교를 거치는 버스는 방학 중에 39.9명이, 학기 중에는 63.8명이 탑승한다는 것을 알 수 있었고 경북대학교를 거치치 않는 버스는 방학 중에 32.2명, 학기 중에는 38.9명이 탑승한다는 결론을 도출할 수 있었다. 경북대학교를 거치는 버스와 거치지 않는 버스를 비교하였을 때 방학 중과 학기 중의 탑승객 수 차이가 각각 약 24명, 6명으로 경북대학교를 거치는 버스의 탑승 인원수가 더 많았다. 등교하는 학생들 때문에 버스의 탑승객 수가 다른 버스들보다 증가하였다고 추론해볼 수 있었다. 또한 경북대학교를 거치는 버스를 보면 학기 중의 탑승객 수는 버스 탑승 규정인 61명을 초과하였다. 결과적으로 그 시간대에 버스를 타는 사람들은 과포화된 버스에 끼여서 타거나, 타지 못하고 다음 버스를 기다려야하는 상황이 발생한다는 것을 보여준다. 이는 경북대학교 학생들 뿐만 아니라 시민들 역시 버스를 이용하기 어렵다는 것을 알 수 있다.<br><br></p>
</section>
<section id="교시-등교의-혼잡함을-줄일-수-있을까" class="level3">
<h3 class="anchored" data-anchor-id="교시-등교의-혼잡함을-줄일-수-있을까"><strong>1교시 등교의 혼잡함을 줄일 수 있을까?</strong></h3>
<p>일반적으로 경북대학교의 수업은 대부분 월/수, 화/목으로 구성되며 월요일이 1교시 수업이라면 수요일에는 1교시 외의 시간대, 대부분 2교시에 수업이 이루어지는 방식을 가진다. 이를 고려해 수강정원이 적은 수업의 강의 시간을 9시로 이동해 버스의 혼잡도를 낮추고 1교시 등교의 부담을 줄이는 방식을 제안하고자 한다.</p>
<p>먼저 경북대학교의 1교시 수업 현황을 파악하기 위해 경북대학교 홈페이지 ’수업 시간/강의계획서’를 참고하여 수업시간에 1A(09:00-9:30)가 포함되는 강의를 조회하였고 그 중 월/수, 화/목으로 구성된 강의를 각 요일마다 9시 수업과 10시 30분 수업으로 나누어 총 수강정원을 구해주었다.</p>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="index_files/figure-html/unnamed-chunk-11-1.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="index_files/figure-html/unnamed-chunk-15-1.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>월/수 강의에서 9시 수업의 총 수강정원은 월요일에 3,115명, 수요일에 6,405명으로 집계되었다. 수요일 1교시 수업을 듣기 위해 등교해야 되는 인원이 월요일에 비해 더 많기 때문에 수요일 아침 시간 통학의 불편함이 더 클 것이라 예상된다. 따라서 월요일 9시와 수요일 10시 30분으로 구성된 강의에서 수강정원이 적은 월요일 1교시를 수요일에도 1교시에 배치하면 동일 시간대로 구성되어 월요일과 수요일의 1교시 통학생이 같아지며 수요일 통학 인원이 줄어들게 되고 버스의 혼잡도가 감소하여 통학생들의 불편함이 줄어들 것이다.</p>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="index_files/figure-html/unnamed-chunk-18-1.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>반면 화/목 강의의 경우, 9시 수업과 그 외 수업 간의 총 수강정원 차이가 나타나지 않아 월/수 수업 구성처럼 수강정원이 적은 수업을 모두 아침시간으로 이동하여 1교시 통학생을 줄이는 방식을 적용할 수 없다.</p>
<p>따라서 새로운 방법으로 월요일과 화요일을 기준으로 구분하여, 9시 수업과 10시 30분 수업을 진행하는 강의의 수강정원을 비교하여 요일 간 총 수강정원의 격차가 있는지 알아보고 그 차이가 존재한다면 수강정원 비중을 조정할 수 있는 방안을 제시하려 한다.</p>
<div class="cell" data-layout-align="center">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="index_files/figure-html/unnamed-chunk-19-1.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>마찬가지로 동일 데이터를 활용하여, 중복되는 월요일과 화요일에 동시에 수업을 하는 강의는 제외하고 총 수강정원을 구해본 결과 월요일을 포함한 강의의 총 수강정원은 13,907명이고 화요일을 포함한 강의의 총 수강정원은 19,743명이었다. 두 요일의 총 수강인원 차이는 약 5,836명 정도이며 특히 화요일을 포함한 강의 중, 화/목 간의 1교시와 2교시 수업 구성의 총 수강정원은 18,839명으로 화요일로 구성된 수업의 수강정원 대부분을 차지하고 있는 것을 확인할 수 있었다. 이를 바탕으로 월요일보다 화/목 9시에 더 많은 인원이 이동하고 버스가 혼잡할 것이라 생각할 수 있다. 따라서 상대적으로 적은 수강정원을 보이는 월요일과 같은 날짜에 화/목 수업을 분배해 준다면 화-목 아침 시간에 밀집되는 통학생을 분산시킬 수 있고 버스를 이용하는 데 있어서도 조금 더 수월할 것이라 생각된다.<br><br></p>
</section>
<section id="장기적인-대책은" class="level3">
<h3 class="anchored" data-anchor-id="장기적인-대책은"><strong>장기적인 대책은?</strong></h3>
<p>본 대안은 단기적으로 상대적인 불편함을 줄일 순 있지만 완전한 해결방안으로 보기는 어렵다.</p>
<p>현재 장기적인 시각에서 통학문제를 해결할 수 있는 대책으로는 대구 도시철도 엑스코선이 언급되고 있다. 2021년 발표된 예비타당성조사 보고서 ’대구 도시철도 엑스코선 건설사업’에 따르면 엑스코선은 3호선 수성구민운동장역에서 동대구역, 경북대학교를 지나 이시아폴리스까지 이어지는 총 연장 12.3km의 도시철도 신설 사업으로 차량시스템은 모노레일로 계획되었다. 본 사업노선의 역별 수송수요 예측 결과 경북대학교가 위치한 역에서 많은 승하차량이 예상되며 사업 시행으로 인한 주변 도로 교통량의 변화로 대구광역시 내부 도로의 교통량이 전반적으로 감소할 것으로 분석된다. 또한 본 사업노선은 대부분 기존의 도시철도 노선이 존재하지 않은 지역을 관통하며 기존 도시철도와의 환승이 가능하도록 연결되어 도시철도-버스 간의 환승을 통해 대구시 전체 도시철도 네트워크와의 연계가 가능할 것으로 보인다.</p>
<p>따라서 경북대학교를 지나는 도시철도 노선이 개통되면 통학생들이 선택할 수 있는 교통수단이 증가해 장기적으로 더 편안한 통학이 가능할 것으로 전망된다.</p>
<p><br><br><br></p>
<div style="text-align: right">
<p><strong>데이터저널리즘 3조</strong><br> 2017111708 국어국문학과 이윤호<br> 2017113417 국어국문학과 변석호<br> 2018113539 레저스포츠학과 신예원<br> 2018114438 미디어커뮤니케이션학과 김아은<br> 2018116311 식품공학부 식품응용공학과 송고은</p>
</div>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    const typesetMath = (el) => {
      if (window.MathJax) {
        // MathJax Typeset
        window.MathJax.typeset([el]);
      } else if (window.katex) {
        // KaTeX Render
        var mathElements = el.getElementsByClassName("math");
        var macros = [];
        for (var i = 0; i < mathElements.length; i++) {
          var texText = mathElements[i].firstChild;
          if (mathElements[i].tagName == "SPAN") {
            window.katex.render(texText.data, mathElements[i], {
              displayMode: mathElements[i].classList.contains('display'),
              throwOnError: false,
              macros: macros,
              fleqn: false
            });
          }
        }
      }
    }
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        typesetMath(container);
        return container.innerHTML
      } else {
        typesetMath(note);
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      typesetMath(note);
      return note.innerHTML;
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>