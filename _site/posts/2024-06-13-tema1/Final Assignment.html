<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.525">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="데이터 저널리즘 1조 장세인 윤성필 장스홍 김현우">
<meta name="dcterms.date" content="2024-07-11">

<title>projects - 대구 대중교통 빈부격차…  서구는 왜 외면당하나</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">projects</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">대구 대중교통 빈부격차… <br> 서구는 왜 외면당하나</h1>
                      </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>데이터 저널리즘 1조<br>장세인<br>윤성필<br>장스홍<br>김현우 </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">July 11, 2024</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<style type="text/css">
  @font-face {
    font-family: 'NanumSquareRound';
    src: url('https://fastly.jsdelivr.net/gh/projectnoonnu/noonfonts_two@1.0/NanumSquareRound.woff') format('woff');
    font-weight: normal;
    font-style: normal;
}
 body{
 font-family: 'NanumSquareRound';}
</style>
<section id="대구-대중교통-빈부격차-서구는-왜-외면당하나" class="level1">
<h1>대구 대중교통 빈부격차… 서구는 왜 외면당하나</h1>
<blockquote class="blockquote">
<p>대구 미래 교통 허브가 될 서구 지역<br> 버스정류소, 버스노선 절대적으로 부족해…<br> 대구지하철 5호선, 서구 반드시 통과해야…</p>
</blockquote>
<p>최근 대구 서구 지역이 대구의 교통 요충지로 부상하며 그 중요성이 대두되고 있다. 행정안전부의 ’주민등록 인구통계’에 따르면 현재 서구 인구는 약 16만 4천 명으로 전년보다 약 4천 명이 늘었고 증가분의 절반이 30대로 젊은 세대 위주의 거주민이 증가하는 추세다.<br><br> 이러한 현상의 중심에는 서대구역이 있다. 서대구역은 개통 2년 만에 이용객 290만 명을 돌파하며 대구 교통의 중심이었던 동대구역을 대신해 대구 서남부권 교통 중심지로 성장하고 있다. 올해 말 개통 예정인 대구권 광역철도, 대구산업선(27년), 신공항철도(30년), 달빛내륙고속철도(30년)까지 4개 철도노선이 추가 개통됨에 따라 서대구역 이용객 수는 꾸준히 증가할 것으로 기대된다.<br><br> 하지만, 이렇게 대구 내에서 서구 지역의 중요성이 증가함에도 불구하고 여전히 서구 지역 대중교통에 대한 잡음은 끊이지 않고 있다. 특히, 새로 개통하는 대구 4호선에 당초 계획된 서구 인구 밀집 지역인 평리동, 내당동, 비산동을 관통하는 지하철역이 제외되고 모든 지하철 노선이 서구를 비껴가면서 서구 주민들은 서구가 지역을 관통하는 도시철도가 하나도 없는 교통오지로 전락하고 있다며 불만을 토했다.<br><br> 서대구역 접근성 개선을 요구하는 목소리 또한 높다. 실제 일부 주민은 거리상 서대구역이 가까움에도 교통편 부족으로 동대구역을 더 자주 방문한다고 말한다.</p>
<blockquote class="blockquote">
<p>“서대구역을 가려면 버스로 가는 방법밖에 없어서 자차로 가지 않는 이상 너무 불편해요. 서대구역 가는 버스가 별로 없는 데다가 배차간격이 커서 그냥 지하철 타고 동대구역으로 가는 게 더 편해요.” - 달서구 주민 장 모 씨(여. 24세)</p>
</blockquote>
<p>이처럼 서구 주민들은 지하철 부재로 인한 불편함과 서대구역 접근성에 대한 문제를 토로하고 있다. 서구 지역 버스 이용 현황과 서대구역 접근성 분석을 통해 실제 주민들이 겪고 있는 불편함에 대한 실태를 알아보았다.</p>
</section>
<section id="서구-지역-버스이용은-얼마나-포화되어-있는가" class="level1">
<h1>서구 지역 버스이용은 얼마나 포화되어 있는가 <br></h1>
<p>지역의 버스 이용이 원활한지를 알아보기 위해 버스 정류소와 버스 노선이 충분히 편재되어 있는지 살펴볼 필요가 있다.<br> 그렇다면, 서구에 버스 정류소는 충분할까? 서구 지역의 버스 정류소는 지역민들의 수요에 적절히 대응하고 있는지 알아보았다. 다음 그래프를 살펴보자.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="Final-Assignment_files/figure-html/unnamed-chunk-14-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>2024년 4월 기준, 전체 정류소의 평균 승객수를 파악하여 구별 버스 이용이 현재 얼마나 포화 상태인가를 알아보았다. 위 자료는 달성군 및 군위군, 그리고 주요 번화가가 밀집해 있는 중구 지역을 제외한 대구시의 주요 주거지역이 형성되어 있는 지역구들의 버스 이용 포화도를 비교한 자료이다.<br><br> 서구는 대구시 전체 이용객 수의 9.2%인 206만 8,782명으로 남구 다음으로 가장 적은 이용객 수 지표를 보이고 있지만 가장 포화도가 높은 것으로 나타났다. 이는 서구 지역에 편재된 버스를 이용할 때 이용객들의 불편함 수준이 타 지역구에 비해 더 높을 가능성이 있음을 의미한다.<br><br> 서구 전체의 대중교통 수요를 버스 혼자 감당하고 있다는 점이 그 원인으로 꼽힌다. 그마저도 이용객 수 대비 정류소 개수가 적어 버스 이용 포화도는 타 지역구에 비해 높은 실정이다. 이를 통해 서구 지역의 지하철 수요가 적을 것이라는 예상 또한 타당하지 않으며, 오히려 타구군 대비 높은 포화도를 이유로 우선적으로 지하철 신설의 혜택을 누려야 하는 지역임을 알 수 있다.<br> <br> 그러나 서구 지역은 이번 대구 4호선 계획에서 철저히 배제되었으며 빨라야 5호선이 개통하는 2033년이 되어야 그 수혜를 입을 수 있다. 더군다나, 서구 지역을 관통하는 지하철 노선이 단 하나도 존재하지 않는 상황 속에서, 유일한 대중교통 수단인 버스 이용에 대한 불편함은 지역민들과 서구 지역 방문객들에게 더욱 크게 다가올 수밖에 없다.<br><br></p>
</section>
<section id="서구지역-버스-노선도-부족하다" class="level1">
<h1>서구지역, 버스 노선도 부족하다</h1>
<section id="서대구역과-동대구역의-비교-전체적인-접근성" class="level2">
<h2 class="anchored" data-anchor-id="서대구역과-동대구역의-비교-전체적인-접근성">서대구역과 동대구역의 비교 : 전체적인 접근성</h2>
<p>부족한 정류소 수뿐만 아니라 노선의 수 또한 서구 지역 주민들이 겪는 불편과 소외감의 큰 원인이 되고 있다. 이러한 문제점은 서구 지역의 교통 허브인 서대구역과 비슷한 목적을 가진 동대구역을 비교하였을 때 현저히 드러난다. 다음 지도를 살펴보자</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="Final-Assignment_files/figure-html/unnamed-chunk-15-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<blockquote class="blockquote">
<p>서대구역과 동대구역의 버스 노선지도. 노선 수와 범위에서 눈에 띄게 차이가 난다.</p>
</blockquote>
<p>서대구역을 지나는 노선은 총 8개이지만 동대구역을 지나는 노선은 20여 개에 이르며 이를 지도상에 표시하면 위와 같다. 서대구역이 범 경상권을 아우르는 교통 허브의 역할을 하기에는 다소 초라한 모습이다. 이는 대구 지역에서 고속철도를 이용하기 위한 접근성에서 서대구역의 경쟁력이 현저히 떨어진다는 의미이다.<br> 8개의 노선밖에 운행이 되지 않아 노선이 지나지 않는 많은 지역에서는 버스, 혹은 도시철도로 환승해서 서대구역으로 가야 한다. 하지만 대부분의 시민은 그런 수고를 들이지 않고 차라리 동대구역을 이용하고 있는 것이 현실이다.<br><br> 다른 지역에서 대구로 오는 경우에도 상황은 비슷하다. 서대구역에서 하차할 시 지하철이 부재하고 편재된 버스 노선이 적기 때문에 가고자 하는 목적지까지 환승이나 다른 교통수단을 추가로 이용해야 할 가능성이 크다. 대구 시민의 경우와 마찬가지 이유로 역시 동대구역을 더 선호하게 될 것이다.</p>
<p>서구 지역의 교통 중추인 서대구역에 편재된 버스가 적기에 서구 지역의 포화한 교통수요를 충족해 줄 수 없다. 지도에서 보이는 것처럼 절대적인 노선 수가 부족하기 때문에 서구에서 다른 지역으로 가기 위해서는 많은 경우 환승이나 다른 수단이 필요하다. 동대구역과의 비교는 차치하고서라도, 이런 문제는 서구 지역 주민들의 교통 불편과 나아가 소외경험까지 초래할 수 있다.</p>
<p>이러한 문제는 도심지로의 이동에서도 발생하고 있다. 다음 지도를 살펴보자.</p>
</section>
<section id="서대구역과-동대구역의-비교-도심으로의-접근성" class="level2">
<h2 class="anchored" data-anchor-id="서대구역과-동대구역의-비교-도심으로의-접근성">서대구역과 동대구역의 비교 : 도심으로의 접근성</h2>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="Final-Assignment_files/figure-html/unnamed-chunk-20-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<blockquote class="blockquote">
<p>도심지역을 확대한 지도. 도심지역에 편재된 노선에서도 큰 차이가 난다.</p>
</blockquote>
<p>위 지도는 노선도를 확대한 것이며 검은 원은 대구의 도심지를 나타낸 것이다. 서구와 서대구역은 대구 전 지역으로의 접근성도 부족하지만, 지도에서 보이는 것처럼 대구 도심으로의 접근성 또한 부족하다. 한눈에 보더라도 동대구역에서 출발하는 노선들이 훨씬 촘촘하게 도심지를 지나는 것을 볼 수 있다. <br><br>이는 결과적으로 서구 지역 주민들은 다른 먼 지역이 아니라 비교적 가까운 도심지역으로 갈 때에도 다른 지역보다 현저히 적은 버스 노선으로 인해 환승이나 다른 교통수단을 이용해야 한다는 것을 의미한다. 이는 앞서 살펴본 것처럼 서구주민의 불편과 소외 감정을 불러일으킬 수 있다.</p>
</section>
</section>
<section id="서구-지역-교통-소외-대책은-없나" class="level1">
<h1>서구 지역 교통 소외, 대책은 없나?</h1>
<p>이처럼 서구 지역은 중심을 통과하는 지하철이 부재해 대중교통 이용 시 버스로 이용객이 몰리지만, 버스 정류소와 버스 노선은 현저히 부족한 실정이다. 따라서, 이러한 문제를 해결하기 위해 단기적으로는 대중교통 접근성이 떨어지는 곳을 조사해 버스 정류소 수를 늘리고 버스 노선을 다양화할 필요가 있다.<br><br> 무엇보다, 서대구역과 서대구역 인근으로의 접근성 개선이 시급하다. 서대구역과의 인접성을 바탕으로 대구 서부권 대표 주거지로 떠오르고 있는 ’평리뉴타운’이 대표적이다. 평리뉴타운 내부로 들어오는 버스 노선은 현재 204번 하나뿐이고 배차간격 또한 20분 안팎이라 주민들이 불편함을 호소하고 있다. 그러므로 평리뉴타운과 서대구역 및 서대구로를 연결하는 대중교통망을 추가로 확보해야 한다.<br><br> 서구 주민들은 당초 지하철 4호선 계획안이 서구 지역을 포함하지 않는 노선으로 변경되어 5호선도 변경되지 않을까 하는 우려의 목소리를 내고 있다. 그러므로 지하철 5호선은 현안과 같이 서구 지역을 통과해야만 한다. 서구 지역을 잇는 도시철도의 신설은 주민들의 불편을 해소하고 서대구역을 더욱 활성화해 서구 지역 교통 소외 문제를 점차 해결하고 지역 발전을 크게 도약시킬 것이다.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    const typesetMath = (el) => {
      if (window.MathJax) {
        // MathJax Typeset
        window.MathJax.typeset([el]);
      } else if (window.katex) {
        // KaTeX Render
        var mathElements = el.getElementsByClassName("math");
        var macros = [];
        for (var i = 0; i < mathElements.length; i++) {
          var texText = mathElements[i].firstChild;
          if (mathElements[i].tagName == "SPAN") {
            window.katex.render(texText.data, mathElements[i], {
              displayMode: mathElements[i].classList.contains('display'),
              throwOnError: false,
              macros: macros,
              fleqn: false
            });
          }
        }
      }
    }
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        typesetMath(container);
        return container.innerHTML
      } else {
        typesetMath(note);
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      typesetMath(note);
      return note.innerHTML;
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>