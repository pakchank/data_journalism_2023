<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.525">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="김이슬 도티프엉타오 서승원 장재호">

<title>projects - 저출산의 진짜 원인: 경제적 불확실성과 젊은 세대의 선택</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">projects</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">저출산의 진짜 원인: 경제적 불확실성과 젊은 세대의 선택</h1>
                      </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>김이슬<br>도티프엉타오<br>서승원<br>장재호 </p>
            </div>
    </div>
      
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="저출산의-진짜-원인-경제적-불확실성과-젊은-세대의-선택" class="level2">
<h2 class="anchored" data-anchor-id="저출산의-진짜-원인-경제적-불확실성과-젊은-세대의-선택"><strong>“저출산의 진짜 원인: 경제적 불확실성과 젊은 세대의 선택”</strong></h2>
<p>저출산 요인의 상관관계를 찾아서</p>
<p>데이터 저널리즘 4조</p>
<div class="cell">
<div class="cell-output cell-output-stderr">
<pre><code>Warning: package 'ggtext' was built under R version 4.3.3</code></pre>
</div>
</div>
<p>한국의 출산율이 지난 몇 년간 꾸준한 하락세를 보이고 있어 사회적 이슈로 떠오르고 있다. 2023년 합계출산율을 보면 전년도 0.78명에 비해 0.06명 감소한 0.72명이라는 소식이 들려왔다. 출생아 수 또한 작년보다 7.7%가 줄어든 23만 명의 수치를 기록했다.</p>
<p>이 같은 저출산의 문제가 한국의 문제만은 아니다. 세계 주요국의 평균 합계출산율은 1960년 이후 반토막이 났고, 경제협력개발기구(OECD)의 ‘한눈에 보는 사회 2024’ 보고서에 따르면 OECD 전체 국가의 평균 합계출산율은 2022년 1.5명까지 떨어졌다고 말한다.</p>
<p>2023년 한국의 합계출산율은 앞서 말한 수치를 기록하면서 OECD 전체 국가의 평균 합계출산율보다 훨씬 낮은 수치임을 알 수 있다. 이와 같이 한국의 출산율이 최저 수치를 기록하며 지속적으로 감소해가는 이유는 과연 무엇일까?</p>
<p>스테파노 스카르페타 OECD 고용노동 및 사회국장은 “OECD 국가들이 출산을 지원하기 위해 다양한 정책을 도입하고 있지만 자녀를 갖는 데 경제적 비용과 장기적인 재정적 불확실성은 사람들이 부모가 되는 결정에 계속 큰 영향을 미치고 있다”고 말한다.</p>
<p>실제 현 우리나라도 다양한 출산 장려 복지정책을 실행하고 있음에도 저출산 문제가 해결되기는 커녕 심화되고있다. 결국 우리는 저출산 문제의 근본적 해결을 위해 이제는 조금 다르게 바라보아야한다는 것이다.</p>
<p>각자 개인의 삶의 가치가 중요시되고있는 사회에서 아기를 낳고 기르는 것도 모두 비용이라 보는 시선이 만연한 가운데 사람들은 자연스레 기회비용에 시선이 돌아가는 사회구조 속에서 살아가고 있다. “의식주” 우리들이 어렸을 때부터 흔히 들은 인간이 최소 인간다운 삶을 영위하기 위해 필요한 필수 3요소이다. 과연 현 우리나라에서 국민들이 이 의식주를 제대로 누릴 수 있는 상황인가 대한 의문을 품고 저출산 문제를 바라볼 필요가 있다.</p>
</section>
<section id="치솟는-물가는-과연-직접적으로-출산율에-영향을-줄까" class="level2">
<h2 class="anchored" data-anchor-id="치솟는-물가는-과연-직접적으로-출산율에-영향을-줄까">치솟는 물가는 과연 직접적으로 출산율에 영향을 줄까?</h2>
<p>물가는 국민의 최대 관심사라고 해도 과언이 아닐 정도이다. 이는 삶의 질과 밀접하게 결부되어있기 때문에 사람들에게 굉장히 예민하게 받아들여질 수 밖에 없다. 이러한 물가의 변동은 과연 직접적으로 출산율과 상관관계를 이루고 있을까?</p>
<p>출산율이 매해 하락하는 것은 모두가 알고 있는 사실이다. 뿐만 아니라 인플레이션도 꾸준하게 이루어지고 있기 때문에 물가지수의 추이와 출산율의 행태가 역으로 비슷한 그림을 그릴 것이라는 것도 대충 유추해볼 수 있다. 하지만 직접적인 상관관계가 있는지를 알아내는 것이 목표이다. 그렇기 때문에 물가의 변동이 출산율의 감소율에 직접적으로 영향을 미치는 지 알아봐야 한다. 다음 그래프는 실제 2014년부터 2023년까지 물가지수와 각 년도 별 전년 대비 출산율 감소율을 비교 분석한 결과이다.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/unnamed-chunk-2-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>그래프를 보면 물가지수가 변동함에 따라 즉각적으로 출산율의 감소율의 폭이 그에 맞게 변화하는 것을 알 수가 있다. 물가지수 그래프와 출산율 감소율 그래프의 모습이 서로 상반되어 반으로 포개지는 모습이 이를 잘 설명해주고 있다.<br>
물가지수가 하락하는 기간에는 그에 맞게 출산율의 감소 비율이 더뎌지는 모습을 보이고 있다. 하지만 반대로 물가지수가 상승하는 기간에는 그 값이 더 커지면서 하방으로 길게 바 그래프를 내리는 모습을 보이고 있다. 이는 유의미한 결과임을 알 수 있다. 이를 보면 출산율 감소율의 추이가 물가지수 추이를 직접적으로 따라간다는 것을 유추해볼 수 있다는 것이다. 결국 인플레이션이 출산율과 직접적인 상관관계를 그리고 있다는 것을 알 수 있다.</p>
</section>
<section id="의식주의-주를-맡고-있는-집값도-예외는-없는-걸까" class="level2">
<h2 class="anchored" data-anchor-id="의식주의-주를-맡고-있는-집값도-예외는-없는-걸까">의식주의 ’주’를 맡고 있는 집값도 예외는 없는 걸까?</h2>
<p>현재 아파트 가격은 거품이라 불릴 정도로 한 없이 높아진 상태에 이르고 있는 것이 사실이다. 경제전문기자 박종훈 저자의 “세대전쟁” 책에선 우리나라 30대 평균 세전 소득인 3,052만원을 받고 있는 30대 청년이 국민 주택규모(25.7평)의 아파트(평균 매매가 4억 2천만원)를 마련하기 위해서는 14년이 걸린다고 말한다. 여기서 14년은 단 한 푼도 쓰지 않았을 때를 말하고 있다. 만약 소득의 3분의 1을 저축하며 모은다고 해도 42년이 걸린다는 것이다. 즉, 현 우리나라는 자기집 마련 조차도 어려운 상황이라는 것이다. 이러한 상황에서 출산율의 하락은 어쩌면 당연한 결과일 것이다.</p>
<p>결국 실제 집값이 사람들의 출산율에 얼마나 영향을 미치는 지에 대해 알아볼 필요가 있다. 지역별로 상이한 집값을 형성하고 있는 가운데, 출산율은 지역별로 어떠한 모습을 보이고 있는지 비교분석을 했다. 더 나아가서 지역별 청년 수를 비교분석하여 출산율과의 연관성을 분석하였다.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/unnamed-chunk-3-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>다음 그래프는 지역을 높은 집값 순으로 왼쪽부터 나열하였고 해당 지역의 출산율을 점으로 나타내었다. 그 결과 서울, 부산, 대구, 인천 순으로 높은 집값을 형성하고 있다는 것을 알 수 있다. 뿐만 아니라 상대적으로 높은 집값을 형성한 지역일 수록 출산율이 낮다는 것을 한 눈에 알 수 있다.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/unnamed-chunk-4-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>다음 그래프는 지역별 청년인구 수이다. 출산율이 낮았던 지역인 서울, 부산, 대구, 인천은 출산율이 낮았음에도 불구하고 청년인구는 상대적으로 높다는 것을 알 수 있다. 결국 높은 아파트 가격대를 형성하고 있는 지역과 낮은 출산율을 기록하고 있는 지역이 어느 정도 일치하고 있는 모습을 보면 아파트 가격도 출산율에 영향을 미치고 있는 것을 짐작해볼 수 있다.</p>
</section>
<section id="그렇다면-청년들은-어디에-있을까" class="level2">
<h2 class="anchored" data-anchor-id="그렇다면-청년들은-어디에-있을까">그렇다면 청년들은 어디에 있을까?</h2>
<p>앞선 그래프 비교에서 저출산 문제와 더불어 수도권에 청년들이 집중되어 있다는 것을 알 수 있다. 이러한 청년들의 수도권 집중 현상은 시간이 지날 수록 심화되고 있는 양상을 띄고 있다. 실제 2018년부터 2023년까지 지역별 청년인구 변화량을 측정해본 결과 다음과 같았다.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/unnamed-chunk-5-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>서울, 경기도의 청년 인구는 지속적으로 증가하는 모습에 반해 나머지 지역 즉, 지방은 지속적으로 줄어들고 있는 모습을 보이는 것을 알 수 있다. 결국 청년들이 수도권으로 집중되고 있는 것이다.</p>
<p>이러한 문제는 저출산의 악순환을 야기시킬 것이라고 보고 있다. 청년들이 많이 말하는 수도권 집중화 현상 중 가장 많은 이유는 ’지방의 적은 일자리’이다. 원하는 직종의 종류와 수가 모두 서울에 몰려있기에 청년들은 자꾸만 수도권을 올라갈 수밖에 없고, 또한 이러한 청년이 희망하는 기업의 대다수가 수도권에 있기에 질적으로, 경제적으로 상호작용이 편리한 서울로 더욱 몰린다. 이에 따라 콘서트, 축제 등의 문화생활 요소도 수도권에 집중하게 된다.</p>
<p>모든 것이 수도권으로 집중할 수 밖에 없는 굴레 속에서 지방의 청년인구는 더욱 줄어들고, 수도권의 그 흡인력은 강해질 수 밖에 없는 것이다. 결국 이 문제는 높은 집값과도 연계될 수 있다. 일자리를 찾기 위해 올라온 청년들은 가장 먼저 직면하게 되는 것은 상대적으로 높은 집값이다. 수도권의 집값은 지방의 집값과 비교했을 때 천지 차이이다. 그렇다고 지방에 내려오기에는 일자리가 부족하다. 그렇기에 젊은 사람들은 수도권 지역으로 올라갈 수 밖에 없게 되고 결국 수도권의 비싼 집값을 견뎌가며 일자리를 구해서 생존할 수 밖에 없게 된다는 것이다. 이러한 상황에서 출산은 물론 둘이서 먹고 살 걱정하기도 바쁠 것이다. 즉, 출산율 저하로 이어질 수 밖에 없고 이러한 악순환이 반복되게 되는 것이다.<br>
</p>
</section>
<section id="우리-사회는-어디를-바라보아야-하는가" class="level2">
<h2 class="anchored" data-anchor-id="우리-사회는-어디를-바라보아야-하는가">우리 사회는 어디를 바라보아야 하는가</h2>
<p>이번 기사에서는 사회 복지 측면에서 많이 바라보는 이전 데이터와 달리 경제적인 지수와 출산율을 직접적으로 비교하여 경제적인 부분이 저출산의 문제에 얼마나 큰 연관이 있는지를 알아보고자 하였다. 물론 그 사이에 다른 변수가 개입할 가능성은 무궁무진함을 알고 있지만, 결과적으로 물가가 오를수록 출산율은 낮아졌고, 부동산 물가가 높은 지역은 출산율이 낮음을 알 수 있었다. 또한 그것이 수도권 몰림과 더불어 불균형적인 대한민국 사회의 문제로 이어지고 있다.</p>
<p>저출산의 문제, 수도권 집중의 문제는 단지 경제의 문제 뿐이 아닌 것을 우리 모두가 알고 있다. 하지만, 우리가 경제적인 측면으로 보려고 했던 것은 아이를 키우는 것, 그리고 우리가 살아가는 것에 가장 중요하게 와닿는 부분이 ’돈’이기 때문이고 실제로 그러한 걱정으로 출산에 섣불리 나아가지 못하는 청년들이 많다. 또한 요즘 아이를 낳아서 행복하게 살자는 생각보다는 스스로 개인의 삶 속에서 행복을 찾아나가자는 생각이 만연하기 때문에 좀처럼 출산율이 늘어날 생각을 하고 있지 않다. 이러한 생각들을 바꾸기 위해서는 급한 불 끄기 식의 지원 정책보다는 국가 시장경제 안정화와 같은 근본적 해결에 초점을 맞추고 정부가 두 발 벗고 나서는 것이 저출산 문제를 해결하는 데에 더욱 효과적일 것이라 보고 있다.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    const typesetMath = (el) => {
      if (window.MathJax) {
        // MathJax Typeset
        window.MathJax.typeset([el]);
      } else if (window.katex) {
        // KaTeX Render
        var mathElements = el.getElementsByClassName("math");
        var macros = [];
        for (var i = 0; i < mathElements.length; i++) {
          var texText = mathElements[i].firstChild;
          if (mathElements[i].tagName == "SPAN") {
            window.katex.render(texText.data, mathElements[i], {
              displayMode: mathElements[i].classList.contains('display'),
              throwOnError: false,
              macros: macros,
              fleqn: false
            });
          }
        }
      }
    }
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        typesetMath(container);
        return container.innerHTML
      } else {
        typesetMath(note);
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      typesetMath(note);
      return note.innerHTML;
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>